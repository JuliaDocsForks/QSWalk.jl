export
  evolve_operator,
  evolve

"""
    evolve_operator(globaloperator, timepoint)

Computes an exponent of `time_point`×`globaloperator`. In the case of multiple
initial states and same `global_operator` and `time_point`, it is faster to
compute exponent once and use it for evolving on different initial states.

*Note*: `global_operator` must be of type `Matrix`, since for `SparseMatrixCSC`
case different numerical approach is used. See function ```epmv``` in package
```Expokit```.

# Examples

```jldoctest
julia> H, L = [0 1; 1 0], [[0 1; 0 0],[0 0; 1 0]]
(
[0 1; 1 0],

Array{Int64,2}[
[0 1; 0 0],

[0 0; 1 0]])

julia> evolve_operator(global_operator(H,L), 4.0)
4×4 Array{Complex{Float64},2}:
 0.499815+0.0im                0.0+0.00127256im         0.0-0.00127256im  0.500185+0.0im
      0.0+0.00127256im  0.00960957+0.0im         0.00870607+0.0im              0.0-0.00127256im
      0.0-0.00127256im  0.00870607+0.0im         0.00960957+0.0im              0.0+0.00127256im
 0.500185+0.0im
```
"""
function evolve_operator(global_operator::Matrix{T} where T<:Number,
                        time_point::Real)
  @argument time_point>=0 "Time need to be nonnegative"
  @argument size(global_operator, 1) == size(global_operator, 2) "global_operator needs to be square"

  expm(time_point*global_operator)
end

"""
    evolve(global_operator, initial_state, time_point)
    evolve(global_operator, initial_state, time_points)
    evolve(exp_global_operator, initial_state)

Simulates the GKSL master equation accordin to the equation

``|result⟩⟩ = exp(time_point*global_operator)|initial_gstate⟩⟩``

where ``|⋅⟩⟩`` denotes vectorization. The function return unvectorized `result`.
List of point of time (`time_points`) can be given. Points of time needs to be
nonnegative (you cannot go back in time). If `global_operator` is of type
`Matrix`, the exponentation is done by `expm` function. If `global_operator` is
of type `SparseMatrixCSC`, `expmv` from `Expokit.jl` is used.

It is up to user to give proper `global_operator` and `initial_state`. For
procedure correctness `globaloperator` should be generated by `global_operator`
function and `initial_state` should be a density matrix.

*Note* The `exp_global_operator` should be generated by `evolveoperator`. This should
be done only in the case of dense matrices with multiple initial states and same
timepoint.

# Examples

```jldoctest
julia> H, L = [0 1; 1 0], [[0 1; 0 0],[0 0; 1 0]]
(
[0 1; 1 0],

Array{Int64,2}[
[0 1; 0 0],

[0 0; 1 0]])

julia> evolve(global_operator(H, L), proj(1,2), 4.)
2×2 Array{Complex{Float64},2}:
 0.499815-0.0im              0.0-0.00127256im
      0.0+0.00127256im  0.500185-0.0im

julia> evolve(global_operator(H, L), proj(1,2), [1.,2.,3.,4.])
4-element Array{Array{Complex{Float64},2},1}:
 Complex{Float64}[0.433203-0.0im 0.0-0.107605im; 0.0+0.107605im 0.566797-0.0im]
 Complex{Float64}[0.485766-0.0im 0.0+0.0171718im; 0.0-0.0171718im 0.514234-0.0im]
 Complex{Float64}[0.505597-0.0im 0.0+0.00261701im; 0.0-0.00261701im 0.494403-0.0im]
 Complex{Float64}[0.499815-0.0im 0.0-0.00127256im; 0.0+0.00127256im 0.500185-0.0im]

```
"""
function evolve(exponentglobaloperator::Matrix{T} where T<:Number,
                initialstate::SparseDenseMatrix)
  @argument size(exponentglobaloperator, 1) == size(exponentglobaloperator, 2) "exponentglobaloperator should be square"
  @argument size(initialstate, 1) == size(initialstate, 2) "initialstate should be square"
  @assert size(exponentglobaloperator, 1) == size(initialstate, 1)^2 "The initial state size should be square root of exponentglobaloperator size"

  unres(exponentglobaloperator*res(initialstate))
end

function evolve(globaloperator::Matrix{T} where T<:Number,
                initialstate::SparseDenseMatrix,
                timepoint::Real)
  @argument size(globaloperator, 1) == size(globaloperator, 2) "globaloperator should be square"
  @argument size(initialstate, 1) == size(initialstate, 2) "initialstate should be square"
  @assert size(globaloperator, 1) == size(initialstate, 1)^2 "The initial state size should be square root of globaloperator size"
  @argument timepoint>=0 "Time needs to be nonnegative"

  unres(expm(timepoint*globaloperator)*res(initialstate))
end

function evolve(globaloperator::SparseMatrixCSC{T} where T<:Number,
                initialstate::SparseDenseMatrix,
                timepoint::Real)
  @argument size(globaloperator, 1) == size(globaloperator, 2) "globaloperator should be square"
  @argument size(initialstate, 1) == size(initialstate, 2) "initialstate should be square"
  @assert size(globaloperator, 1) == size(initialstate, 1)^2 "The initial state size should be square root of globaloperator size"
  @argument timepoint>=0 "Time needs to be nonnegative"
  unres(expmv(timepoint, globaloperator, full(res(initialstate))))
end

function evolve(globaloperator::SparseDenseMatrix,
                initialstate::SparseDenseMatrix,
                timepoints::Vector{T} where T<:Number)
  @argument size(globaloperator, 1) == size(globaloperator, 2) "globaloperator should be square"
  @argument size(initialstate, 1) == size(initialstate, 2) "initialstate should be square"
  @assert size(globaloperator, 1) == size(initialstate, 1)^2 "The initial state size should be square root of globaloperator size"
  @argument all(timepoints.>=0) "All time points need to be nonnegative"

  [evolve(globaloperator,initialstate,t) for t=timepoints]
end
