export
  evolveoperator,
  evolve



"""
    evolve(globaloperator, timepoint)

Computes an exponent of `timepoint`×`globaloperator`. In the case of multiple
initial states and same `globaloperator` and `timepoint`, it is faster to compute
exponent once and use it for evolving on different initial states. `globaloperator`
must be of type `Matrix`, since for `SparseMatrixCSC` case different numerical
approach is used.

# Examples

```jldoctest


```
"""
function evolveoperator(globaloperator::Matrix{T} where T<:Number,
                        timepoint::Real)
  @argument timepoint>=0 "Time need to be nonnegative"
  expm(timepoint*globaloperator)
end

"""
    evolve(globaloperator, initialstate, timepoint)
    evolve(globaloperator, initialstate, timepoints)
    evolve(exponentglobaloperator, initialstate)

Simulates the GKSL master equation accordin to the equation

``|result⟩⟩ = exp(timepoint*globaloperator)|initialstate⟩⟩``

where ``|⋅⟩⟩`` denotes vectorization. The function return unvectorized `result`.
List of point of time (`timepoints`) can be given. Points of time needs to be
nonnegative (you cannot go back in time). If `globaloperator` is of type `Matrix`,
the exponentation is done by `expm` function. If `globaloperator` is of type
`SparseMatrixCSC`, `expmv` from `Expokit.jl` is used.

It is up to user to give proper `globaloperator` and `initialstate`. For
procedure correctness `globaloperator` should be generated by `globaloperator` function
and `initialstate` should be a density matrix.

The `exponentglobaloperator` should be generated by `evolveoperator`. This should be
done only in the case of dense matrices with multiple initial states and same
timepoint.

# Examples

```jldoctest
julia> H, L = [0 1; 1 0], [[0 1; 0 0],[0 0; 1 0]]
(
[0 1; 1 0],

Array{Int64,2}[
[0 1; 0 0],

[0 0; 1 0]])

julia> evolve(globaloperator(H, L), proj(1,2), 4.)
2×2 Array{Complex{Float64},2}:
 0.499815-0.0im              0.0-0.00127256im
      0.0+0.00127256im  0.500185-0.0im

julia> evolve(globaloperator(H, L), proj(1,2), [1.,2.,3.,4.])
4-element Array{Array{Complex{Float64},2},1}:
 Complex{Float64}[0.433203-0.0im 0.0-0.107605im; 0.0+0.107605im 0.566797-0.0im]
 Complex{Float64}[0.485766-0.0im 0.0+0.0171718im; 0.0-0.0171718im 0.514234-0.0im]
 Complex{Float64}[0.505597-0.0im 0.0+0.00261701im; 0.0-0.00261701im 0.494403-0.0im]
 Complex{Float64}[0.499815-0.0im 0.0-0.00127256im; 0.0+0.00127256im 0.500185-0.0im]

```
"""
function evolve(exponentglobaloperator::Matrix{T} where T<:Number,
                initialstate::SparseDenseMatrix)
  #TODO: argument i assert dotyczące wymiarowości
  unres(exponentglobaloperator*res(initialstate))
end

function evolve(globaloperator::Matrix{T} where T<:Number,
                initialstate::SparseDenseMatrix,
                timepoint::Real)
  #TODO: argument i assert dotyczące wymiarowości
  @argument timepoint>=0 "Time needs to be nonnegative"
  unres(expm(timepoint*globaloperator)*res(initialstate))
end

function evolve(globaloperator::SparseMatrixCSC{T} where T<:Number,
                initialstate::Matrix{S} where S<:Number,
                timepoint::Real)
  #TODO: argument i assert dotyczące wymiarowości
  @argument timepoint>=0 "Time needs to be nonnegative"
  unres(expmv(timepoint, globaloperator, res(initialstate)))
end

function evolve(globaloperator::SparseDenseMatrix,
                initialstate::SparseDenseMatrix,
                timepoints::Vector{T} where T<:Number)
  #TODO: argument i assert dotyczące wymiarowości
  @argument all(timepoints.>=0) "All timepoints needs to be nonnegative"

  [evolve(globaloperator,initialstate,t) for t=timepoints]
end
