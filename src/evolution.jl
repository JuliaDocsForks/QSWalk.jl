export
  evolve_operator,
  evolve

"""
    evolve_operator(global_operator, timepoint)

Computes an exponent of `time_point`×`global_operator`. In the case of multiple
initial states and same `global_operator` and `time_point`, it is faster to
compute exponent once and use it for evolving on different initial states.

*Note*: `global_operator` must be of type `Matrix`, since for `SparseMatrixCSC`
case different numerical approach is used. See function ```epmv``` in package
```Expokit```.

# Examples

```jldoctest
julia> H, L = [0 1; 1 0], [[0 1; 0 0],[0 0; 1 0]]
(
[0 1; 1 0],

Array{Int64,2}[
[0 1; 0 0],

[0 0; 1 0]])

julia> evolve_operator(global_operator(H,L), 4.0)
4×4 Array{Complex{Float64},2}:
 0.499815+0.0im                0.0+0.00127256im         0.0-0.00127256im  0.500185+0.0im
      0.0+0.00127256im  0.00960957+0.0im         0.00870607+0.0im              0.0-0.00127256im
      0.0-0.00127256im  0.00870607+0.0im         0.00960957+0.0im              0.0+0.00127256im
 0.500185+0.0im
```
"""
function evolve_operator(global_operator::Matrix{T} where T<:Number,
                        time_point::Real)
  @argument time_point>=0 "Time need to be nonnegative"
  @argument size(global_operator, 1) == size(global_operator, 2) "global_operator needs to be square"

  expm(time_point*global_operator)
end

"""
    evolve(exp_global_operator, initial_state)

    evolve(global_operator, initial_state, time_point)
    evolve(global_operator, initial_state, time_points)

Simulates the GKSL master equation accordin to the equation

``|result⟩⟩ = exp(time_point*global_operator)|initial_gstate⟩⟩``

where ``|⋅⟩⟩`` denotes vectorization. The function return unvectorized `result`.
List of point of time (`time_points`) can be given. Points of time needs to be
nonnegative (you cannot go back in time). If `global_operator` is of type
`Matrix`, the exponentation is done by `expm` function. If `global_operator` is
of type `SparseMatrixCSC`, `expmv` from `Expokit.jl` is used.

It is up to user to give proper `global_operator` and `initial_state`. For
procedure correctness `global_operator` should be generated by `global_operator`
function and `initial_state` should be a density matrix.

*Note* The `exp_global_operator` should be generated by `evolveoperator`. This should
be done only in the case of dense matrices with multiple initial states and same
timepoint.

# Examples

```jldoctest
julia> H, L = [0 1; 1 0], [[0 1; 0 0],[0 0; 1 0]]
(
[0 1; 1 0],

Array{Int64,2}[
[0 1; 0 0],

[0 0; 1 0]])

julia> evolve(global_operator(H, L), proj(1,2), 4.)
2×2 Array{Complex{Float64},2}:
 0.499815-0.0im              0.0-0.00127256im
      0.0+0.00127256im  0.500185-0.0im

julia> evolve(global_operator(H, L), proj(1,2), [1.,2.,3.,4.])
4-element Array{Array{Complex{Float64},2},1}:
 Complex{Float64}[0.433203-0.0im 0.0-0.107605im; 0.0+0.107605im 0.566797-0.0im]
 Complex{Float64}[0.485766-0.0im 0.0+0.0171718im; 0.0-0.0171718im 0.514234-0.0im]
 Complex{Float64}[0.505597-0.0im 0.0+0.00261701im; 0.0-0.00261701im 0.494403-0.0im]
 Complex{Float64}[0.499815-0.0im 0.0-0.00127256im; 0.0+0.00127256im 0.500185-0.0im]

julia> ev_op = evolve_operator(global_operator(H, L), 4.)
4×4 Array{Complex{Float64},2}:
 0.499815+0.0im                0.0+0.00127256im         0.0-0.00127256im  0.500185+0.0im
      0.0+0.00127256im  0.00960957+0.0im         0.00870607+0.0im              0.0-0.00127256im
      0.0-0.00127256im  0.00870607+0.0im         0.00960957+0.0im              0.0+0.00127256im
 0.500185+0.0im                0.0-0.00127256im         0.0+0.00127256im  0.499815+0.0im

julia> evolve(ev_op, proj(1,2))
2×2 Array{Complex{Float64},2}:
 0.499815+0.0im              0.0+0.00127256im
      0.0-0.00127256im  0.500185+0.0im
```
"""
function evolve(exp_global_operator::Matrix{T} where T<:Number,
                initial_state::SparseDenseMatrix)
  @argument size(exponentglobal_operator, 1) == size(exponentglobal_operator, 2) "exponentglobal_operator should be square"
  @argument size(initial_state, 1) == size(initial_state, 2) "initial_state should be square"
  @assert size(exponentglobal_operator, 1) == size(initial_state, 1)^2 "The initial state size should be square root of exponentglobal_operator size"

  unres(exponentglobal_operator*res(initial_state))
end

function evolve(global_operator::Matrix{T} where T<:Number,
                initial_state::SparseDenseMatrix,
                timepoint::Real)
  @argument size(global_operator, 1) == size(global_operator, 2) "global_operator should be square"
  @argument size(initial_state, 1) == size(initial_state, 2) "initial_state should be square"
  @assert size(global_operator, 1) == size(initial_state, 1)^2 "The initial state size should be square root of global_operator size"
  @argument timepoint>=0 "Time needs to be nonnegative"

  unres(expm(timepoint*global_operator)*res(initial_state))
end

function evolve(global_operator::SparseMatrixCSC{T} where T<:Number,
                initial_state::SparseDenseMatrix,
                timepoint::Real)
  @argument size(global_operator, 1) == size(global_operator, 2) "global_operator should be square"
  @argument size(initial_state, 1) == size(initial_state, 2) "initial_state should be square"
  @assert size(global_operator, 1) == size(initial_state, 1)^2 "The initial state size should be square root of global_operator size"
  @argument timepoint>=0 "Time needs to be nonnegative"
  unres(expmv(timepoint, global_operator, full(res(initial_state))))
end

function evolve(global_operator::SparseDenseMatrix,
                initial_state::SparseDenseMatrix,
                timepoints::Vector{T} where T<:Number)
  @argument size(global_operator, 1) == size(global_operator, 2) "global_operator should be square"
  @argument size(initial_state, 1) == size(initial_state, 2) "initial_state should be square"
  @assert size(global_operator, 1) == size(initial_state, 1)^2 "The initial state size should be square root of global_operator size"
  @argument all(timepoints.>=0) "All time points need to be nonnegative"

  [evolve(global_operator,initial_state,t) for t=timepoints]
end
